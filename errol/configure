#!/bin/sh
# Generated by BetterMake
# md5sum: 4125ebb3f65e1eb5cb48dbb17007f682

##
# ltrim Function
#   Trim all whitespace off of the front of the input string.
# Version
#   1.0
# Parameters
#   string input
#     The input string to be trimmed.
# Printed
#   The input string with the whitespace removed off of the front side.
#.

ltrim()
{
	printf '%s' "${*#"${*%%[!`printf '\t\v\r\n '`]*}"}"
}

##
# rtrim Function
#   Trim all whitespace off of the end of the input string.
# Version
#   1.0
# Parameters
#   string input
#     The input string to be trimmed.
# Printed
#   The input string with the whitespace removed off of the end.
#.

rtrim()
{
	printf '%s' "${*%"${*##*[!`printf '\t\v\r\n '`]}"}"
}

##
# trim Function
#   Trim all whitespace off of both the front and back of the input string.
# Version
#   1.0
# Parameters
#   string input
#     The input string to be trimmed.
# Printed
#   The input string with the whitespace removed.
#.

trim()
{
	rtrim "`ltrim "$*"`"
}

##
# quote Function
#   Given the input string, it places it within single quotes, making sure that
#   any single quotes within the string are properly escaped.
# Version
#   1.1
# Parameters
#   string input
#     The input text.
# Printed
#   Prints out the quoted string.
#.

quote()
{
	__quote_str="$*"

	if [ "${__quote_str#*[\'\"\\`printf '\t\v\r\n '`]}" = "$__quote_str" ] ; then
		printf %s "$__quote_str"
		return
	fi

	while [ 1 ]
	do
		__quote_piece="${__quote_str%%\'*}"
		test "$__quote_piece" = "$__quote_str" && break
		printf "'%s'\\'" "$__quote_piece"
		__quote_str="${__quote_str#*\'}"
	done

	printf %s "'$__quote_str'"
}

replace()
{
	printf '%s' "${1%%"$2"*}"

	if [ -z "${1%%*"$2"*}" ] ; then
		printf '%s' "$3"
		replace "${1#*"$2"}" "$2" "$3"
	fi
}

##
# firstchar Function
#   Used to process a string by returning the first character of a string.
# Version
#   1.0
# Parameters
#   string input
#     The input string.
# Printed
#   A first character of the input string.
#.

firstchar()
{
	printf '^s' "${*%"${*#?}"}"
}

##
# ifeval Function
#   Processes an input, looking for all of conditional statement of 'If',
#   'ElseIf', 'Else', and 'EndIf'. All of the expressions are evaluated using
#   the shell 'eval' function and placing the conditionally expression in the
#   form of 'if __expr__ ;'.
# Parameters
#   string input
#     The text input.
# Printed
#   All conditional lines and blocks of text inside a conditional evaluating
#   false are replaced with a blank line.
#.

ifeval()
{
	__level=0
	__spaces="`printf ' \t\n'`"
	__curval=''

	while read line
	do
		if [ "${line#If["$__spaces"]}" != "$line" ] ; then
			__level=$(($__level + 1))

			if [ -z "$__curval" ] ; then
				eval "if ${line#If} ; then __retval='1' ; else __retval='' ; fi"
				test -z "$__retval" && __curval=$__level
			fi
			echo
		elif [ "${line#ElseIf["$__spaces"]}" != "$line" ] ; then
			if [ "$__curval" ] ; then
				if [ $__level -eq $__curval ] ; then
					eval "if ${line#ElseIf} ; then __retval='1' ; else __retval='' ; fi"
					test "$__retval" && __curval=''
				fi
			else
				__curval=$__level
			fi
			echo
		elif [ "${line#Else}" != "$line" ] ; then
			if [ "$__curval" ] ; then
				test $__level -eq $__curval && __curval=''
			else
				__curval=$__level
			fi
			echo
		elif [ "${line#EndIf}" != "$line" ] ; then
			test "$__curval" && test $__level -eq $__curval && __curval=''
			__level=$(($__level - 1))
		else
			if [ "$__curval" ] ; then
				echo
			else
				echo "$line"
			fi
		fi
	done
}

##
# src_hasargs Function
#   Check that there are no more arguments passed in the given string.
# Parameters
#   string args
#     The command arguments as a string.
# Return Value
#   Returns '0' if more arguments remain, '1' otherwise.
#.

src_hasargs()
{
	if [ "${value%%[`printf '\t\v\r\n '`]*}" ] ; then
		return 0
	else
		return 1
	fi
}

##
# src_nextval Function
#   Retrieves the next quoted value from the input variable. The first argument
#   in the value string is removed from the variable upon success completion of
#   the function.
# Parameters
#   string var
#     The name of the variable containing the value.
#   string dest
#     The name of the variable where the result will be stored.
# Printed
#   Prints the parsed value.
#.

src_nextval()
{
	eval '__tmp="$'$1'"'
	__tmp_dest=""

	case "$__tmp" in
	\"*)
		__tmp_val="${__tmp#\"*[!\\]\"}"

		test "$__tmp_val" = "$__tmp" && return 1
		__tmp="${__tmp%"$__tmp_val"}"
		__tmp="${__tmp%\"}"
		__tmp="${__tmp#\"}"

		while true ; do
			__tmp_dest="$__tmp_dest`printf %s "${__tmp%%\\\"*}"`"

			test "${__tmp#*\\\"}" = "$__tmp" && break

			__tmp="${__tmp#*\\\"}"
			__tmp_dest="$__tmp_dest\\"
		done

		eval $1="`quote "$__tmp_val"`"
		eval $2="`quote "$__tmp_dest"`"

		;;
	
	*)
		__tmp="${__tmp#"${__tmp%%[!`printf '\t\v\r\n '`]*}"}"
		test "$__tmp" || return 1
		;;
	esac

	return 0
}

##
# src_err Function
#   Produces an error message when parsing the sources file. The error
#   message contains the filename, line number, and error message, and is
#   written to the standard error stream. The script never returns from this
#   function; instead, it directly exits with an error code of '1'.
# Parameters
#   string message
#     The text error message to be printed.
#.

src_err()
{
	test -f "$tmpfile" && rm -f "$tmpfile"
	echo "sources: $lineno: $*" >&2
	exit 1
}

##
# src_process Function
#   Inputs the sources configuration file and produces the corresponding
#   makefile.
# Parameters
#   string infile
#     The name of the input sources file.
#   string outfile
#     The name of the output makefile.
#.

src_process()
{
	test ! -f "$1" && return 1
	rm -f "$2"

	package="package"	# Package name
	pkgver=""	# Package version
	lineno=0	# Line number
	target=""	# Current target
	type=""		# Target type
	objlist=""	# List of object for the current target
	targetlist=""	# List of targets to be built
	depdirlist=""	# List of dependency directories
	depinclist=""	# List of dependency paths to include
	installdeps=""	# Dependencies for installation
	install=""	# Commands for installation
	clean=""	# Commands for cleaning
	cleanlist=""	# Files to be cleaned
	pch=""		# Precompile header dependency
	distlist=""	# List of files to distribute
	testlist=""	# List of test targets

	tmpfile=tempfile
	ifeval < "$1" > "$tmpfile"

	while read -r line
	do
		lineno=$((lineno + 1))

		line="`trim "$line"`"
		test -z "$line" && continue

		command="${line%%[`printf '\t\v\r\n '`]*}"
		value="`trim "${line#"$command"}"`"

		case "$command" in
		"Package")
			test "$target" && src_err "'Package' directive not allowed inside the 'Target' directive."
			src_nextval value package || src_err "Missing argument for the 'Package' directive."
			src_hasargs "$value" && src_err "Too many arguments passed to the 'Package' directive."
			;;

		"Target")
			src_hasargs "$value" && src_err "Too many arguments passed to the 'Target' directive."
			test "$target" && src_err "Target already defined as '$target'."
			target="default"
			cflags="" ; reqcflags="" ; ldflags="" ; objlist="" ; prereq="" ; installprefix=""
			;;

		"Name")
			test -z "$target" && src_err "No target defined"
			src_nextval value target || src_err "Invalid parameter"
			src_hasargs "$value" && src_err "Too many arguments passed to the 'Name' directive."
			;;

		"Type")
			test -z "$target" && src_err "No target defined"
			src_nextval value type || src_err "Invalid parameter"
			src_hasargs "$value" && src_err "Too many arguments passed to the 'Type' directive."

			case "$type" in
			"Application")
				;;

			"TestApplication")
				;;

 			"Library")
				test "$pic" && reqcflags="$reqcflags -fpic"
				;;

			*)
				src_err "Invalid target type '$type'"
			esac

			;;

		"Version")
			if [ "$target" ] ; then
				test "$version" && src_err "Target version already defined"
				src_nextval value version || src_err "Invalid parameter"
				src_hasargs "$value" && src_err "Too many arguments passed to the 'Version' directive."
			else
				test "$pkgver" && src_err "Package version already defined"
				src_nextval value pkgver || src_err "Invalid parameter"
				src_hasargs "$value" && src_err "Too many arguments passed to the 'Version' directive."
			fi
			;;

		"Source")
			test -z "$target" && src_err "No target defined"
			src_nextval value source || src_err "Missing source file"
			src_nextval value filetype || {
				case $source in
				*.c)
					filetype="C,H"
					;;

				*)
					src_err "Unknown file extension '.${source##*.}'"
				esac
			}
			src_hasargs "$value" && src_err "Too many arguments passed to the '$command' directive."

			if [ -z "${filetype%%*,H}" ] ; then
				filetype="${filetype%,H}"
				if [ -e "${source%.*}.h" ] ; then
					header="${source%.*}.h"
					distlist="$distlist `quote "$header"`"
				fi
			fi

			case "$filetype" in
			"C")
				printf '%s.o: %s%s%s\n' "${source%.*}" "$source" "$pch" "$prereq" >> "$2"
				printf '\t$(bmake_PRECC)\n' >> "$2"
				printf '\t$(CC)%s%s $(CFLAGS) -c $< -o $@\n\n' "$reqcflags" "$cflags" >> "$2"
				objlist="$objlist ${source%.*}.o"
				cleanlist="$cleanlist ${source%.*}.o"
				distlist="$distlist `quote "$source"`"

				dir="${source%/*}"
				test "$dir" = "$source" && dir="."

				if [ -z "$depinclist" ] ; then
					depinclist="$depinclist $dir/.deps/*"
				elif [ "${depinclist%*" $dir/.deps "*}" ] && [ "${depinclist%*" $dir/.deps"}" ] ; then
					depinclist="$depinclist $dir/.deps/*"
				fi

				;;

			*)
				src_err "Unknown filetype '$filetype'"
			esac

			;;
		
		"Extra")
			while src_nextval value tmpval
			do
				distlist="$distlist `quote "$tmpval"`"
			done
			;;
		
		"CFlags")
			test -z "$target" && src_err "No target defined"
			if [ ! "${value%%+*}" ] ; then
				value="${value#+}"
			else
				cflags=""
			fi

			while src_nextval value tmpval
			do
				cflags="$cflags $tmpval"
			done
			;;
		
		"LDFlags")
			test -z "$target" && src_err "No target defined"
			if [ ! "${value%%+*}" ] ; then
				value="${value#+}"
			else
				ldflags=""
			fi

			while src_nextval value tmpval
			do
				ldflags="$ldflags $tmpval"
			done
			;;
		
		"PreReq")
			test -z "$target" && src_err "No target defined"
			if [ ! "${value%%+*}" ] ; then
				value="${value#+}"
			else
				prereq=""
			fi

			while src_nextval value tmpval
			do
				prereq="$prereq $tmpval"
			done
			;;
		
		"PCH")
			test -z "$target" && src_err "No target defined"
			src_nextval value pch || src_err "Missing header file"
			src_hasargs "$value" && src_err "Too many arguments passed to the 'PCH' directive."
			printf '%s.gch: %s%s\n' "$pch" "$pch" "$cdeps" >> "$2"
			printf '\t$(bmake_PRECC)\n' >> "$2"
			printf '\t$(CC)%s%s $(CFLAGS) -c $< -o $@\n\n' "$reqflags" "$cflags" >> "$2"
			pch=" $pch.gch"
			;;

		"InstallPrefix")
			test -z "$target" && src_err "No target defined"
			src_nextval value installprefix || src_err "Missing header file"
			src_hasargs "$value" && src_err "Too many arguments passed to the 'InstallPrefix' directive."
			;;

		"EndTarget")
			test -z "$target" && src_err "No target defined"
			test -z "$type" && type="Application"

			case "$type" in
			"Application")
				printf '%s:%s\n' "$target" "$objlist" >> "$2"
				printf '\t$(LD) $^%s -o $@ $(LDFLAGS)\n\n' "$ldflags" >> "$2"
				targetlist="$targetlist $target"
				installdeps="$installdeps $target"
				install="$install`printf '\n\tinstall --mode 0755 -D %s "%s/%s%s"' "$target" "$bindir" "$installprefix" "$target"`"
				cleanlist="$cleanlist $target"
				;;

			"TestApplication")
				printf '%s:%s\n' "$target" "$objlist" >> "$2"
				printf '\t$(LD) $^%s $(LDFLAGS) -o $@\n\n' "$ldflags" >> "$2"
				testlist="$testlist $target"
				;;

			"Library")
				printf 'lib%s.a:%s\n' "$target" "$objlist" >> "$2"
				printf '\t$(AR) $@ $^\n\n' >> "$2"
				targetlist="$targetlist lib$target.a"
				installdeps="$installdeps lib$target.a"
				install="$install`printf '\n\tinstall --mode 0644 -D lib%s.a "%s/%slib%s.a"' "$target" "$libdir" "$installprefix" "$target"`"
				cleanlist="$cleanlist lib$target.a"

				if [ "$dynlib" = "so" ] ; then
					test -z "$version" && version="$pkgver"
					test -z "$version" && version="0.0.1"
					shortversion="${version%%.*}"
					
					printf 'lib%s.so.%s:%s\n' "$target" "$version" "$objlist" >> "$2"
					printf '\t$(LD) $^%s $(LDFLAGS) -shared -Wl,-soname,lib%s.so.%s -o $@\n' "$ldflags" "$target" "$shortversion" >> "$2"
					printf '\tln -fs lib%s.so.%s lib%s.so.%s\n' "$target" "$version" "$target" "$shortversion" >> "$2"
					printf '\tln -fs lib%s.so.%s lib%s.so\n\n' "$target" "$version" "$target" >> "$2"
					targetlist="$targetlist `printf 'lib%s.so.%s' "$target" "$version"`"
					installdeps="$installdeps `printf 'lib%s.so.%s' "$target" "$version"`"
					install="$install`printf '\n\tinstall --mode 0755 -D lib%s.so.%s "%s/%slib%s.so.%s"' "$target" "$version" "$libdir" "$installprefix" "$target" "$version"`"
					install="$install`printf '\n\tln -fs lib%s.so.%s "%s/%slib%s.so"' "$target" "$version" "$libdir" "$installprefix" "$target"`"
					install="$install`printf '\n\tln -fs lib%s.so.%s "%s/%slib%s.so.%s"\n\n' "$target" "$version" "$libdir" "$installprefix" "$target" "$shortversion"`"
					cleanlist="$cleanlist `printf 'lib%s.so.%s lib%s.so.%s lib%s.so' "$target" "$version" "$target" "$shortversion" "$target"`"
				elif [ "$dynlib" = "dll" ] ; then
					printf 'lib%s.dll:%s\n' "$target" "$objlist" >> "$2"
					printf '\t$(LD) -shared -Wl,--out-implib,lib%s.dll.a -Wl,--enable-auto-import -o $@ $^%s $(LDFLAGS)\n\n' "$target" "$ldflags" >> "$2"
					targetlist="$targetlist `printf 'lib%s.dll' "$target"`"
					installdeps="$installdeps `printf 'lib%s.dll' "$target"`"
					install="$install`printf '\n\tinstall --mode 0644 -D lib%s.dll.a "%s/lib%s.dll.a"\n' "$target" "$libdir" "$target"`"
					install="$install`printf '\n\tinstall --mode 0755 -D lib%s.dll "%s/lib%s.dll"' "$target" "$bindir" "$target"`"
					cleanlist="$cleanlist `printf 'lib%s.dll lib%s.dll.a' "$target" "$target"`"
				fi

				;;
			*)
				src_err "Invalid target type '$type'"
				;;
			esac

			target=""
			;;

		*)
			src_err "Unhandled directive '$command'"
			echo "$command"
			;;
		esac
	done < "$tmpfile"

	rm -f "$tmpfile"
	test "$target" && src_err "Unterminated 'Target' directive'"

	pkgname="`quote "$package"`"
	test "$pkgver" && pkgname="$pkgname-`quote "$pkgver"`"

	printf 'bmake_all:%s\n\n' "$targetlist" >> "$2"
	printf 'bmake_test:%s\n\n' "$testlist" >> "$2"
	printf 'bmake_install:%s%s\n\n' "$installdeps" "$install" >> "$2"
	printf 'bmake_clean:%s\n\trm -rf config.status config.log%s%s\n\n' "$clean" "$cleanlist" "$depinclist" >> "$2"
	printf 'bmake_dist:\n' >> "$2"
	printf '\tif [ -e %s ] ; then rm -rf %s ; fi ; mkdir %s\n' "$pkgname" "$pkgname" "$pkgname" >> "$2"
	printf '\tcp --parents configure Makefile.in $(wildcard mktests/* sources user.mk)%s %s\n' "$distlist" "$pkgname" >> "$2"
	printf '\ttar -zcf %s.tar.gz %s/\n' "$pkgname" "$pkgname" >> "$2"
	printf '\trm -rf %s\n\n' "$pkgname" >> "$2"
	printf 'sinclude%s\n\n' "$depinclist" >> "$2"
	#printf 'dist:\n\ttar -zcf pack.tar.gz configure Makefile.in\n\n'
	printf '.PNOHY: bmake_install bmake_clean\n' >> "$2"

}

##
# exec_tests Function
#.

exec_tests()
{
	# Makefile and config.h headers
	echo "# autogenerated by configure script" > Makefile
	cat <<EOF > "$config"
#ifndef CONFIG_H
#define CONFIG_H

#define BMAKE__PATH_PREFIX	"$prefix"
#define BMAKE__PATH_BIN		"$bindir"
#define BMAKE__PATH_LIB		"$libdir"
#define BMAKE__PATH_INCLUDE	"$includedir"
#define BMAKE__PATH_SHARE	"$sharedir"
#define BMAKE__PATH_CONF	"$confdir"

#define BMAKE__HOST		"$host"

EOF

	# Run through all the scripts
	for script in mktests/[0-9][0-9]-*
	do
		test ! -f "$script" && continue
		rm -f mktests/tmp*
		. $script
	done
	rm -f mktests/tmp*

	# Optional variables
	test "$cc" && echo "bmake_CC = $cc" >> Makefile			# C compiler
	test "$precc" && echo "bmake_PRECC = @$precc" >> Makefile	# Before c compilation commands
	test "$ld" && echo "bmake_LD = $ld" >> Makefile			# Linker

	# Mandatory variables
	echo "bmake_CFLAGS = $CFLAGS" >> Makefile	# C compiler flags
	echo "bmake_LDFLAGS = $LDFLAGS" >> Makefile	# Linker flags
	echo "bmake_HOST = $host" >> Makefile		# Target host

	# Path variables
	echo "bmake_PATH_PREFIX = $prefix" >> Makefile
	echo "bmake_PATH_BIN = $bindir" >> Makefile
	echo "bmake_PATH_LIB = $libdir" >> Makefile
	echo "bmake_PATH_INCLUDE = $includedir" >> Makefile
	echo "bmake_PATH_SHARE = $sharedir" >> Makefile
	echo "bmake_PATH_CONF = $confdir" >> Makefile

	echo "#endif" >> "$config"			# End of config.h generation
	echo "# end autogenerated content" >> Makefile	# End of Makefile generation

	test -f "Makefile.in" && cat "Makefile.in" >> "Makefile"	# Append Makefile.in
}

##
# build_config_status Function
#.

build_config_status()
{
	rm -rf config.status
	echo -n "$0" > config.status
	#shift
	for param in "$@"
	do
		echo -n " `quote "$param"`" >> config.status
	done
	echo >> config.status
	chmod +x config.status
}

config="config.h"	# Configuration header
configlog="config.log"	# Configure script log

rm -f "$configlog"			# Clear config log to start
test -e "src" && config="src/$config"	# Change config.h to be in the 'src'

CFLAGS=""	# C compiler flags
LDFLAGS=""	# Linker flags
toolchain=""	# Toolchain used for compilation
prefix=""	# Installation prefix
bindir=""	# Binary installation directory
libdir=""	# Library installation directory
sharedir=""	# Share installation directory
depdir=""	# Name of dependency directory

# Append arguments in config.args
test -f config.args && eval set -- "`cat config.args | tr '\n\t' '  '`"

# Parse parameters
for opt in "$@"
do
	if [ -z "$optname" ] ; then
		if [ "$opt" != "${opt%%=*}" ] ; then
			optname=${opt%%=*}
			opt=${opt#*=} 
		else
			optname="$opt"
			unset opt
		fi
	fi

	case "$optname" in
		--build)
			test -z "$opt" && continue ; build="$opt" ;;

		--host)
			test -z "$opt" && continue ; host="$opt" ;;

		--toolchain | --prefix | --libdir | --bindir | --includedir | --confdir | --depdir)
			test -z "$opt" && continue ; eval "${optname#--}=`quote "$opt"`" ;;

		--infodir | --sysconfdir | --localstatedir | --libexedir)
			echo "option '$optname' not supported yet" ;;

		--disable-maintainer-mode | --disable-dependency-tracking)
			echo "unsuppoted option '$optname'" ;;

		cc | ld | CC | LD | CFLAGS | LDFLAGS )
			test -z "$opt" && continue ; eval "$optname=`quote "$opt"`" ;;

		*)
			echo "invalid option $optname"
			exit 1
			;;
	esac

	unset optname
done

test ! -z $optname && echo "'$optname' requires parameter" && exit 1

# Setup build flags
cflags="$CFLAGS"
ldflags="$LDFLAGS"

# Setup directories
test -z "$prefix" && prefix="/usr/local"
test -z "$bindir" && bindir="$prefix/bin"
test -z "$libdir" && libdir="$prefix/lib"
test -z "$includedir" && includedir="$prefix/include"
test -z "$sharedir" && sharedir="$prefix/share"
test -z "$confdir" && confdir="$prefix/etc"
test -z "$depdir" && depdir=".deps"

# Normalize parameters
test "$toolchain" && toolchain="$toolchain-"

exec_tests			# Execute tests, building config.h and Makefile
src_process sources sources.mk	# Process sources to build sources.mk
build_config_status "$@"	# Build config.status file

# Update all the files that configure depends on, Makefile always last
test -f sources && touch sources
test -f config.args && touch config.args
for file in mktests/[0-9][0-9]-* ; do test -f "$file" && touch "$file" ; done
touch Makefile
